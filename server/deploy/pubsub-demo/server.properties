# The below regular expression makes it so that the default principal created during SSL authentication, taking the
# example form of "CN=Broker,OU=Unknown,O=Unknown,L=Unknown,ST=Unknown,C=Unknown", gets transformed into just "broker"
#
#                                                                Choose first capture group as the principal
#                                                                ^
#                                                                | Make principal lowercase
#                           Describes the 1st rule               | ^
#                           ^                 Capture CN         | | If the first rule doesn't match, use the default one
#                           |                 ^                  | | ^
ssl.principal.mapping.rules=RULE:^.*[Cc][Nn]=([a-zA-Z0-9.]*).*$/$1/L,DEFAULT
# We also need to make the principals derived from the above rule super users, that's declared inside the compose file with KAFKA_SUPER_USERS
# We use mTLS on the controller and internal ssl listeners, the below two lines turn on ssl authentication requirement for these two listeners
listener.name.controller.ssl.client.auth=required
listener.name.int_ssl.ssl.client.auth=required

# Management listener will use Keycloak for authentication
listener.name.mgmt.ssl.client.auth=none
listener.name.mgmt.sasl.enabled.mechanisms=OAUTHBEARER
listener.name.mgmt.oauthbearer.sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \
	oauth.client.id="kafka-broker-introspection" \
	oauth.client.secret="ZB5iVlPMEwzHKbDAWx6lfKatZA3UeVZx" \
	oauth.introspection.endpoint.uri="http://keycloak:8080/realms/master/protocol/openid-connect/token/introspect" \
	oauth.valid.issuer.uri="http://keycloak:8080/realms/master" \
	unsecuredLoginStringClaim_sub="unused" ;
listener.name.mgmt.oauthbearer.sasl.server.callback.handler.class=io.strimzi.kafka.oauth.server.JaasServerOauthValidatorCallbackHandler
principal.builder.class=io.strimzi.kafka.oauth.server.OAuthKafkaPrincipalBuilder
# This enables re-authentication
listener.name.mgmt.connections.max.reauth.ms=3600000
# This enables Keycloak based authorization
authorizer.class.name=io.strimzi.kafka.oauth.server.authorizer.KeycloakAuthorizer
strimzi.authorization.token.endpoint.uri=http://keycloak:8080/realms/master/protocol/openid-connect/token
strimzi.authorization.client.id=kafka-broker-introspection
# Immediately retry on grant fetch failure
strimzi.authorization.http.retries=1
# Delegate to StandardAuthorizer in the case of an action not being granted by Keycloak
strimzi.authorization.delegate.to.kafka.acl=true

# Device listener will use JWT tokens generated by RDFM management server for authentication
listener.name.dev.ssl.client.auth=none
listener.name.dev.sasl.enabled.mechanisms=PLAIN
listener.name.dev.plain.sasl.server.callback.handler.class=com.antmicro.rdfm.DeviceAuthenticateCallbackHandler
listener.name.dev.plain.sasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required \
	username="admin" \
	password="admin-secret" \
	user_admin="admin-secret" \
	user_alice="alice-secret";
